---
layout: default
title: JS. Зачем ты такой?
---

![Birdphant](/assets/img/birdphant.jpg)
Именно эта картинка приходит мне в голову, когда я думаю о JS.

Я прекрасно понимаю, что это гибкий, расширяемый язык с большими возможностями, но черт возьми, иногда его поведение мало того что непредсказуемо, так еще и идёт вразрез с логикой. Кстати, для этого языка специально придумали величину WTFPS(What the fuck per second)

Что именно меня не устраивает? Давайте по порядку.

Начнем с простейших вещей. Есть 2 переменные значения которых нужно поменять местами. Для примера посмотрим как это делается в Ruby

    irb(main):001:0> a = 1
    => 1
    irb(main):002:0> b = 2
    => 2
    irb(main):003:0> a,b = b,a
    => [2, 1]
    irb(main):004:0> a
    => 2
    irb(main):005:0> b
    => 1

Заранее извиняюсь, мои познания в Ruby оставляют желать лучшего.
В JS это решается еще проще(сарказм)

    x = x + y;
    y = x - y;
    x = x - y;
    Mind = blown;

Или вот еще элементарная задача. Есть массив(array), необходимо взять последний элемент.

    > var a = [1,2,3];
    > a[-1];
    undefined

Что вполне себе даже логично, ну невозможно взять отрицательный индекс и всё тут. Тут приходит на помощь свойство length, обозначающее количество элементов в массиве. Теоретически мы можем пойти на небольшую хитрость, от количества элементов(length) отнимаем единицу и получаем последний индекс.

    > var a = [1,2,3];
    > a[a.length - 1];

Несколько некрасиво, но главное ведь заработало!

FALSE. Похакать достаточно просто.

    > var a = [1,2,3];
    > a.length = 9001; // OVER 9000!
    > a[a.length - 1];
    undefined

Массивы в JS вообще заслуживают отдельной статьи. Ну или премии изобретателю. Результаты выполнения простейшей функции sort могут привести в замешательство даже человека с крепкой психикой.

    > [1,2,13].sort();
    [1, 13, 2]

Я отказываюсь это комментировать. Точее, я просто не знаю что тут сказать.

Я очень часто в своем коде прибегаю к использованию map/filter. И тут есть чему нас удивить!

    > ["10","10","10"].map(parseInt);
    [10, NaN, 2]

Продолжая тему массивов давайте попробуем сравнить.

    > var a = [1,2,3];
    > a === [1,2,3];
    false

Хм, может я делаю что-то не так? Попробуем по-другому

    > [1,2,3] === [1,2,3];
    false
    > [1,2,3] === Array(1,2,3);
    false

Что-то не так, видимо кто-то поменял местами true и false. Надо проверить.

    > [1,2,3] !== [1,2,3];
    true
    > [1,2,3] !== new Array(1,2,3);
    true

А ведь действительно! Плавно перемещаемся в сторону true/false

    > if (false) console.log(false);

Хм, всё правильно! Однако..

    > if (FALSE = new Boolean(false)) console.log(FALSE + " is actually " + true);

Вот, всё встало на свои места. На самом деле загвоздка в приведении типов. Естественно, самое вкусное я приберег напоследок.

Попробуем сложить 2 массива

    > [1,2,3] + [4,5,6];
    "1,2,34,5,6"

Конечно получаем string, это же так очевидно! Кстати

    > [] + [];
    ""

А попробуем ка мы сложить с объектом

    > [] + {};
    "[object Object]"

Ну всё понятно, вполне ожидаемое поведение. А помните в детстве нас учили, что от перемены мест слагаемых сумма не меняется? Вот забудте.

    > {} + [];
    0

Ну это было очевидно, конечно должен получиться ноль. Чего вы еще ожидали? А если сложить два объекта?

    > {} + {};
    NaN

Я всегда догадывался.. Кстати, тут маленький бонус можете менять переменные местами, "сумма" не поменяется :)

{{ page.date | date: "%d %B %Y" }}

[link to this post]({% post_url 2013-03-12-js %})
